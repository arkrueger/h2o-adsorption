import numpy as np

'''
function find_mean_Z
This function finds all data points at the desired saturation (+/- a specified tolerance) at each time "slice" 
and finds the average of the corresponding Z-values. In other words, Z-values are a measure of how the saturation 
progresses up the column with time. Recall that each time "slice" is an image of the color-changing 
silica column which produces a data set relating saturation and Z-position. If the saturation of interest  
is 50%, this function returns a 1D array (length: number of time points of given trial) containing a series of Z-values 
that express how far the line of 50% saturation has progressed along the column at each time point.

Big picture: 
This function is useful for two purposes. The first is to fit the parameter psi at saturation = 50% (at 
50% saturation the governing equations simplify such that psi is the slope of the Z vs. tau trendline). For further 
explanation see the ReadMe. The second purpose is to fit the parameter kappa by nonlinear regression. To do this 
directly with the S matrix (i.e. generate an S matrix from a guessed kappa value, compute a score of closeness between 
the two S matrices, and attempt to minimize this score by guessing new kappas) would be both needlessly complex and 
susceptible to over-fitting. Instead, the Z-values at three representative saturation levels are used. 
The Z-values are a useful measure of the overall trend of the data set. This is useful because it gives us a way to 
reduce the complexity of the data, as the S matrix has dimensions [# of time points]x[# of Z points]. In this analysis, 
we will look at the data set generated by find_mean_Z for 3 saturation levels. The specific points can depend on the 
quality and spread of the data, but typically 35%, 50%, and 65% saturation work well to capture important inflection 
points for nonlinear regression. By reducing this large matrix to 3 much smaller data sets, much less time and 
computation power is required to fit the parameter kappa.

Visualization:
The first set of graphs (count: number of time points of given trial) show the Z-values selected for averaging
at each time point. The second set (count: one) shows all points on axes Z vs. tau. 
'''


# noinspection PyPep8Naming
def find_mean_Z(S_matrix, saturation, show_graphs=0):
    # S_matrix is the S matrix from a single trial of a given configuration
    # tau_factor is used to convert time to the dimensionless tau
    # saturation is the value of S at which the value of Z is averaged
    # show_graphs toggles the graphing feature (1 means show, 0 means hide)

    # Returns:
    # mean_Z, An array containing a series of Z-values (length: number of time points of given trial)
    # fit, an array containing the polynomial coefficients from the (linear) fit made to the Z vs. tau plot

    tolerance = 0.01  # No values will be exactly at the specified saturation; this is the +/- tolerance range
    # For each row (time step) find the indices whose elements satisfy the condition of being close to the specified
    # saturation level and take the mean of those indices. Divide by the length of that dimension to normalize.
    # Note: we aren't interested in the saturation values directly here, but the Z values. That's why the index is
    # used, because the x2 index represents z-position (technically, pixels).
    mean_Z = np.array([np.mean(np.argwhere(abs(row - saturation) < tolerance)) for row in S_matrix]) / S_matrix.shape[1]
    # Leave the NaN values in there. Important to preserve spacing because the index is the time axis.

    # TODO graphing component
    # For the graphing, keep the non-dimensional scaled Z
    # BUT just use frames or minutes for the time axis because it communicates what is happening more clearly than
    # tau does
    if show_graphs == 1:
        print('test')
        # do graphing

    # TODO consider having an if statement that toggles between the long way to get mean_Z and the concise one
    #  depending if show_graphs is selected

    return mean_Z


